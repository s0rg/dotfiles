#!/usr/bin/env python3
# source: https://github.com/s0rg/dotfiles
#
# JWT decoder
#

import sys
import argparse
import json
from base64 import urlsafe_b64decode
from datetime import datetime

from pygments import highlight, lexers, formatters

lexer = lexers.JsonLexer()
tform = formatters.TerminalFormatter()

parser = argparse.ArgumentParser(description="JWT-tokens decoder")
parser.add_argument("-s",
                    "--sign",
                    action="store_true",
                    help="also show signature block")
parser.add_argument("input", nargs='?', help="JWT to decode")


def fancy_json(v):
    r = json.loads(v)
    v = json.dumps(r, sort_keys=True, indent=4)
    return (r, highlight(v, lexer, tform))


def decode(p):
    return urlsafe_b64decode(p + "==")


def main():
    args = parser.parse_args()

    val = args.input
    if val is None:
        val = sys.stdin.read().strip()

    parts = val.split(".")
    if len(parts) != 3:
        print("malformed jwt!", file=sys.stderr)
        return 1

    raw = json.loads(decode(parts[0]))
    if raw.get("typ", "") != "JWT":
        print("non-jwt!", file=sys.stderr)
        return 1

    alg = raw["alg"]

    print("\n---")

    raw, fancy = fancy_json(decode(parts[1]))
    exp = datetime.utcfromtimestamp(raw["exp"]).strftime("%Y-%m-%d %H:%M:%S")

    print(fancy)
    print(f"\x1B[30mexpire at\x1B[0m: \x1B[1;37m{exp}\x1B[0m UTC")
    print(f"\x1B[30malgorithm\x1B[0m: \x1B[32m{alg}\x1B[0m")

    if args.sign:
        sig = decode(parts[2]).hex()
        print(f"\x1B[30msignature\x1B[0m: \x1B[32m{sig}\x1B[0m")
        print()

    print("---\n")

    return 0


if __name__ == '__main__':
    sys.exit(main())

#vim:ft=py3
